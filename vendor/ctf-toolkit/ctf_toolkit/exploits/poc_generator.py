"""Base PoC (Proof of Concept) generator for CTF challenges."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import html
import json
import base64


class PocType(Enum):
    """Types of PoC exploits."""
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    XSS_DOM = "xss_dom"
    CSRF = "csrf"
    SQLI_ERROR = "sqli_error"
    SQLI_UNION = "sqli_union"
    SQLI_BLIND = "sqli_blind"
    SQLI_TIME = "sqli_time"
    CMDI = "cmdi"
    SSRF = "ssrf"
    LFI = "lfi"
    SSTI = "ssti"


@dataclass
class PocResult:
    """Result of PoC generation."""
    poc_type: PocType
    target_url: str
    payload: str
    
    # Generated artifacts
    html_file: Optional[str] = None
    curl_command: Optional[str] = None
    python_script: Optional[str] = None
    
    # Evidence
    evidence_description: str = ""
    steps_to_reproduce: list[str] = field(default_factory=list)
    expected_result: str = ""
    
    # Metadata
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())
    callback_url: Optional[str] = None
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "poc_type": self.poc_type.value,
            "target_url": self.target_url,
            "payload": self.payload,
            "html_file": self.html_file,
            "curl_command": self.curl_command,
            "python_script": self.python_script,
            "evidence_description": self.evidence_description,
            "steps_to_reproduce": self.steps_to_reproduce,
            "expected_result": self.expected_result,
            "generated_at": self.generated_at,
            "callback_url": self.callback_url,
        }
    
    def to_markdown(self) -> str:
        """Generate markdown report."""
        md = f"""# PoC Report: {self.poc_type.value.upper()}

**Generated**: {self.generated_at}  
**Target URL**: `{self.target_url}`

## Payload

```
{self.payload}
```

## Evidence Description

{self.evidence_description}

## Steps to Reproduce

"""
        for i, step in enumerate(self.steps_to_reproduce, 1):
            md += f"{i}. {step}\n"
        
        md += f"""
## Expected Result

{self.expected_result}
"""
        
        if self.curl_command:
            md += f"""
## cURL Command

```bash
{self.curl_command}
```
"""
        
        if self.python_script:
            md += f"""
## Python Exploit Script

```python
{self.python_script}
```
"""
        
        if self.html_file:
            md += f"""
## HTML PoC File

Saved to: `{self.html_file}`
"""
        
        return md


class PocGenerator(ABC):
    """Base class for PoC generators."""
    
    def __init__(
        self,
        target_url: str,
        param: Optional[str] = None,
        method: str = "GET",
        data: Optional[dict] = None,
        headers: Optional[dict] = None,
        cookies: Optional[dict] = None,
    ):
        self.target_url = target_url
        self.param = param
        self.method = method.upper()
        self.data = data or {}
        self.headers = headers or {}
        self.cookies = cookies or {}
        
        # Parse URL
        self.parsed_url = urlparse(target_url)
        self.query_params = parse_qs(self.parsed_url.query)
    
    @abstractmethod
    def generate(self, **kwargs) -> PocResult:
        """Generate PoC. Override in subclasses."""
        pass
    
    def save_html(self, content: str, filename: str, output_dir: str = ".") -> str:
        """Save HTML content to file in target-specific folder."""
        # Create target-based folder
        target_folder = self._get_target_folder()
        full_output_dir = Path(output_dir) / target_folder
        full_output_dir.mkdir(parents=True, exist_ok=True)
        
        output_path = full_output_dir / filename
        
        # Handle duplicate files with numbering
        if output_path.exists():
            base = output_path.stem
            ext = output_path.suffix
            counter = 1
            while output_path.exists():
                output_path = full_output_dir / f"{base}_{counter}{ext}"
                counter += 1
        
        output_path.write_text(content, encoding="utf-8")
        return str(output_path.absolute())
    
    def save_script(self, content: str, filename: str, output_dir: str = ".") -> str:
        """Save script content to file in target-specific folder."""
        target_folder = self._get_target_folder()
        full_output_dir = Path(output_dir) / target_folder
        full_output_dir.mkdir(parents=True, exist_ok=True)
        
        output_path = full_output_dir / filename
        
        # Handle duplicate files with numbering
        if output_path.exists():
            base = output_path.stem
            ext = output_path.suffix
            counter = 1
            while output_path.exists():
                output_path = full_output_dir / f"{base}_{counter}{ext}"
                counter += 1
        
        output_path.write_text(content, encoding="utf-8")
        return str(output_path.absolute())
    
    def _get_target_folder(self) -> str:
        """Get folder name based on target URL."""
        # Extract domain and sanitize for folder name
        netloc = self.parsed_url.netloc
        
        # Remove port if present for cleaner folder names
        if ":" in netloc:
            domain, port = netloc.rsplit(":", 1)
            folder_name = f"{domain}_port{port}"
        else:
            folder_name = netloc
        
        # Sanitize folder name (remove invalid characters)
        folder_name = "".join(c if c.isalnum() or c in "._-" else "_" for c in folder_name)
        
        return folder_name
    
    def build_url_with_payload(self, payload: str) -> str:
        """Build URL with payload injected into parameter."""
        if not self.param:
            return self.target_url
        
        # Copy query params and inject payload
        new_params = {k: v[0] if len(v) == 1 else v for k, v in self.query_params.items()}
        new_params[self.param] = payload
        
        # Rebuild URL
        new_query = urlencode(new_params, safe="")
        new_url = urlunparse((
            self.parsed_url.scheme,
            self.parsed_url.netloc,
            self.parsed_url.path,
            self.parsed_url.params,
            new_query,
            self.parsed_url.fragment,
        ))
        
        return new_url
    
    def generate_curl_command(
        self,
        url: str,
        method: str = "GET",
        data: Optional[dict] = None,
        headers: Optional[dict] = None,
        cookies: Optional[dict] = None,
    ) -> str:
        """Generate curl command for the request."""
        cmd_parts = ["curl", "-v"]
        
        # Method
        if method != "GET":
            cmd_parts.extend(["-X", method])
        
        # Headers
        all_headers = {**self.headers, **(headers or {})}
        for name, value in all_headers.items():
            cmd_parts.extend(["-H", f"'{name}: {value}'"])
        
        # Cookies
        all_cookies = {**self.cookies, **(cookies or {})}
        if all_cookies:
            cookie_str = "; ".join(f"{k}={v}" for k, v in all_cookies.items())
            cmd_parts.extend(["-H", f"'Cookie: {cookie_str}'"])
        
        # Data
        all_data = {**self.data, **(data or {})}
        if all_data:
            if "application/json" in str(all_headers.get("Content-Type", "")):
                cmd_parts.extend(["-d", f"'{json.dumps(all_data)}'"])
            else:
                cmd_parts.extend(["-d", f"'{urlencode(all_data)}'"])
        
        # URL (quoted)
        cmd_parts.append(f"'{url}'")
        
        return " ".join(cmd_parts)
    
    def escape_html(self, text: str) -> str:
        """Escape HTML special characters."""
        return html.escape(text)
    
    def escape_js(self, text: str) -> str:
        """Escape JavaScript special characters."""
        return (
            text
            .replace("\\", "\\\\")
            .replace("'", "\\'")
            .replace('"', '\\"')
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("<", "\\x3c")
            .replace(">", "\\x3e")
        )
    
    def base64_encode(self, text: str) -> str:
        """Base64 encode text."""
        return base64.b64encode(text.encode()).decode()
